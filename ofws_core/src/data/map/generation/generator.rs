use crate::data::map::Map2d;
use crate::data::math::generator::generator2d::{Generator2d, Generator2dData};
use serde::{Deserialize, Serialize};
use std::convert::{TryFrom, TryInto};

/// Modifies an [`Attribute`] with the values generated by a [`Generator2d`].
pub struct GeneratorStep {
    name: String,
    attribute_id: usize,
    generator: Generator2d,
}

impl GeneratorStep {
    pub fn new<S: Into<String>>(
        name: S,
        attribute_id: usize,
        generator: Generator2d,
    ) -> GeneratorStep {
        GeneratorStep {
            name: name.into(),
            attribute_id,
            generator,
        }
    }

    // Adds the values.
    ///
    /// ```
    ///# use ofws_core::data::map::Map2d;
    ///# use ofws_core::data::map::generation::generator::GeneratorStep;
    ///# use ofws_core::data::map::generation::GenerationStep;
    ///# use ofws_core::data::math::generator::generator2d::Generator2d::IndexGenerator;
    ///# use ofws_core::data::math::size2d::Size2d;
    /// let size = Size2d::new(2, 3);
    /// let mut map = Map2d::new(size);
    /// let attribute_id = map.create_attribute("elevation", 40).unwrap();
    /// let generator = IndexGenerator(size);
    /// let step = GeneratorStep::new("test", attribute_id, generator);
    ///
    /// step.add(&mut map);
    ///
    /// let attribute = map.get_attribute(attribute_id);
    /// assert_eq!(attribute.get_all(), &vec![40u8, 41, 42, 43, 44, 45]);
    /// ```
    pub fn add(&self, map: &mut Map2d) {
        info!(
            "Add '{}' to attribute '{}' of map '{}'",
            self.name,
            map.get_attribute(self.attribute_id).get_name(),
            map.get_name()
        );

        let size = map.size;
        let attribute = map.get_attribute_mut(self.attribute_id);
        let mut index = 0;

        for y in 0..size.height() {
            for x in 0..size.width() {
                let value = self.generator.generate(x, y);
                let sum = attribute.get(index).saturating_add(value);
                *attribute.get_mut(index) = sum;
                index += 1;
            }
        }
    }

    // Subtracts the values.
    ///
    /// ```
    ///# use ofws_core::data::map::Map2d;
    ///# use ofws_core::data::map::generation::generator::GeneratorStep;
    ///# use ofws_core::data::map::generation::GenerationStep;
    ///# use ofws_core::data::math::generator::generator2d::Generator2d::IndexGenerator;
    ///# use ofws_core::data::math::size2d::Size2d;
    /// let size = Size2d::new(2, 3);
    /// let mut map = Map2d::new(size);
    /// let attribute_id = map.create_attribute("elevation", 40).unwrap();
    /// let generator = IndexGenerator(size);
    /// let step = GeneratorStep::new("test", attribute_id, generator);
    ///
    /// step.sub(&mut map);
    ///
    /// let attribute = map.get_attribute(attribute_id);
    /// assert_eq!(attribute.get_all(), &vec![40u8, 39, 38, 37, 36, 35]);
    /// ```
    pub fn sub(&self, map: &mut Map2d) {
        info!(
            "Subtract '{}' from attribute '{}' of map '{}'",
            self.name,
            map.get_attribute(self.attribute_id).get_name(),
            map.get_name()
        );

        let size = map.size;
        let attribute = map.get_attribute_mut(self.attribute_id);
        let mut index = 0;

        for y in 0..size.height() {
            for x in 0..size.width() {
                let value = self.generator.generate(x, y);
                let sum = attribute.get(index).saturating_sub(value);
                *attribute.get_mut(index) = sum;
                index += 1;
            }
        }
    }
}

/// For serializing, deserializing & validating [`GeneratorStepData`].
///
///```
///# use ofws_core::data::map::generation::generator::{GeneratorStepData, GeneratorStep};
///# use ofws_core::data::math::generator::generator2d::Generator2dData;
///# use ofws_core::data::math::size2d::Size2d;
///# use std::convert::TryInto;
/// let generator = Generator2dData::IndexGenerator(Size2d::new(1, 2));
/// let data = GeneratorStepData::new("10".to_string(), 20, generator);
/// let step: GeneratorStep = data.clone().try_into().unwrap();
/// let result: GeneratorStepData = step.into();
/// assert_eq!(data, result)
///```
#[derive(new, Debug, PartialEq, Eq, Clone, Serialize, Deserialize)]
pub struct GeneratorStepData {
    name: String,
    attribute_id: usize,
    generator: Generator2dData,
}

impl TryFrom<GeneratorStepData> for GeneratorStep {
    type Error = &'static str;

    fn try_from(data: GeneratorStepData) -> Result<Self, Self::Error> {
        let generator: Generator2d = data.generator.try_into()?;
        Ok(GeneratorStep::new(data.name, data.attribute_id, generator))
    }
}

impl From<GeneratorStep> for GeneratorStepData {
    fn from(step: GeneratorStep) -> Self {
        GeneratorStepData::new(step.name, step.attribute_id, step.generator.into())
    }
}
